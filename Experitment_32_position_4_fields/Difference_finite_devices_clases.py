from tqdm import tqdm
import matplotlib.pyplot as plt
import numpy as np
import numpy.linalg as LA
import warnings
from scipy.sparse import csr_matrix
from numpy import random
import pandas as pd
import scipy
from scipy import sparse
from scipy.sparse import csr_matrix, lil_matrix
from scipy.sparse import kron, diags, vstack
from scipy.sparse.linalg import spsolve
warnings.filterwarnings('ignore')


import time

def coil_magnetic_field_total_fast(coordinates_nodes, coil_segments, coil_current):
    """
    Calculate the magnetic field at position rv due to a coil with multiple line segments.
    Parameters:
    rv (numpy.ndarray): Position vector of the vth voxel.
    coil_segments (numpy.ndarray): Array of start and end points of the coil line segments.
    coil_current (float): Current carried by the coil.
    
    Returns:
    numpy.ndarray: Magnetic field at position rv.
    """
  
    # start_time = time.time()
    coil_segments = np.array(coil_segments)

    # --- 1. Vectorized Coil Magnetic Field Calculation ---
    f1 = coil_segments[:, 0, :]  # Shape: (n_segments, 3)
    f2 = coil_segments[:, 1, :]  # Shape: (n_segments, 3)
    
    r1 = coordinates_nodes[None, :, :] - f1[:, None, :]  # Shape: (n_segments, n_nodes, 3)
    r2 = coordinates_nodes[None, :, :] - f2[:, None, :]  # Shape: (n_segments, n_nodes, 3)
    
    norm_f1 = LA.norm(r1, axis=2)  # Shape: (n_segments, n_nodes)
    norm_f2 = LA.norm(r2, axis=2)  # Shape: (n_segments, n_nodes)
    
    f1_mult_wis_f2 = norm_f1 * norm_f2  # Shape: (n_segments, n_nodes)
    f1_cross_f2 = np.cross(r1, r2, axis=2)  # Shape: (n_segments, n_nodes, 3)
    dot_f1_f2 = np.einsum('ijk,ijk->ij', r1, r2)  # Shape: (n_segments, n_nodes)
    
    numerator = (norm_f1 + norm_f2) * coil_current  # Shape: (n_segments, n_nodes)
    denominator = f1_mult_wis_f2 * (f1_mult_wis_f2 + dot_f1_f2)  # Shape: (n_segments, n_nodes)
    
    Hc_v_segments = (numerator[:, :, None] / denominator[:, :, None]) * f1_cross_f2  # Shape: (n_segments, n_nodes, 3)
    Hv = np.sum(Hc_v_segments, axis=0) / (4 * np.pi)  # Shape: (n_nodes, 3)
    # end_time = time.time()
    # print('time magnetic_fields', end_time-start_time)

    return Hv


    




def lead_field_matrix_coil_Hv_fn_DF(parameters,points,ddx, N, a_s, coordinates_nodes,Hv,fn_i, function_sensitive=None):
    """
    here it works for fn_i with saturation 
    IT MIGHT ONLY WORKS FOR ONE SENSOR AT TIME
    **check the reshape of the points, but for the moment it works for only one sensor which are interested

    Computes the lead field matrix for a coil using vectorized operations for efficiency.

    This function is for Difference finites it is an adaptation of the function for FEM lead_field_matrix_coil_fast3_Hv_fn

    Parameters:
    - parameters (dict): Dictionary of parameters, including 'e_direction_sensor' and 'mu'.
   
    - ddx 
    - N (int): Number of discretization points for each size of the plate sensors .
    - ddx: size of the discretization of each plate sensor size
    - points: array  of the discretization points in each plate sensor  
    - a_s (np.ndarray): Array of sensor orientations (shape: (n_sensors, 3)).
    - basis_function_test: Finite element test function (needed for assemble).
    - H_v magnetic field generated by coil_segments and  coil_current 
    - a_s is the sensitive axis of the sensor 

    Returns:
    np.ndarray: Lead field matrix (shape: (n_sensors, n_nodes)).
    """
    mu = parameters['mu']

    # array of the point for eac sensosr
    sensors = points.reshape(1,len(points), 3)

    # print(x_min, x_max )
    # print(sensors)
    # sensors = np.tile(sensors, (n_sensors, 1, 1))
    # print(sensors.shape)
    # --- 2.1 Vectorized ker_R_si_coil Calculation ---
    r = coordinates_nodes[None, None, :, :] - sensors[:, :, None, :]  # Shape: (n_sensors, N*N, n_nodes, 3)
    e_coil = Hv[None, None, :, :]  # Shape: (1, 1, n_nodes, 3)
    norm_r = LA.norm(r, axis=-1, keepdims=True)  # Shape: (n_sensors, N*N, n_nodes, 1)
    
    R = (3 * r * np.sum(e_coil * r, axis=-1, keepdims=True)) / (norm_r ** 5) - e_coil / (norm_r ** 3)  # Shape: (n_sensors, N*N, n_nodes, 3)
    
    

    if parameters['e_direction_sensor'] == 'sensor':
        e_sensor = a_s / np.linalg.norm(a_s, axis=-1, keepdims=True)  # Shape: (n_sensors, 1 , 3)
        e_sensor=e_sensor[:,None,:]
    else:
        e_sensor = sensors / np.linalg.norm(sensors, axis=-1, keepdims=True)  # Shape: (n_sensors, N*N, 3)
    
    L = np.abs(np.sum(e_sensor[:,:, None, :] * R, axis=-1)  )# Shape: (n_sensors, N*N, n_nodes)
    
    
    # --- 2.2 Integration ---
    if function_sensitive is None:
        ker_values=L
    else:
        sensitive_inf = function_sensitive[np.newaxis,:,np.newaxis]*L
        ker_values=sensitive_inf


    integral = fn_i[:np.newaxis]*np.sum(ker_values * ddx * ddx, axis=1)  # Shape: (n_sensors, n_nodes)


    return (mu / (4 * np.pi)) * integral



def lead_field_matrix_coil_Hv_DF(parameters,points,ddx, N, a_s, coordinates_nodes,Hv):
    """
    here the Hv is works without a saturation 
    Computes the lead field matrix for a coil using vectorized operations for efficiency.

    This function combines all the necessary steps into a single function for ease of use.

    Parameters:
    - parameters (dict): Dictionary of parameters, including 'e_direction_sensor' and 'mu'.
    - Space: Finite element function space object (needed for assemble and dx).
    - sensor_start (np.ndarray): Array of sensor start positions (shape: (n_sensors, 3)).
    - sensor_end (np.ndarray): Array of sensor end positions (shape: (n_sensors, 3)).
    - N (int): Number of discretization points for sensor line integration.
    - a_s (np.ndarray): Array of sensor orientations (shape: (n_sensors, 3)).
    - coordinates_nodes (np.ndarray): Array of node coordinates (shape: (n_nodes, 3)).
    - basis_function_test: Finite element test function (needed for assemble).
    - H_v magnetic field generated by coil_segments and  coil_current 

    Returns:
    np.ndarray: Lead field matrix (shape: (n_sensors, n_nodes)).
    """
    mu = parameters['mu']
    sensors = points.reshape(1, N*N, 3)
    # print(x_min, x_max )
    # print(sensors)
    # sensors = np.tile(sensors, (n_sensors, 1, 1))
    # print(sensors.shape)
    # --- 2.1 Vectorized ker_R_si_coil Calculation ---
    r = coordinates_nodes[None, None, :, :] - sensors[:, :, None, :]  # Shape: (n_sensors, N*N, n_nodes, 3)
    e_coil = Hv[None, None, :, :]  # Shape: (1, 1, n_nodes, 3)
    norm_r = LA.norm(r, axis=-1, keepdims=True)  # Shape: (n_sensors, N*N, n_nodes, 1)
    
    R = (3 * r * np.sum(e_coil * r, axis=-1, keepdims=True)) / (norm_r ** 5) - e_coil / (norm_r ** 3)  # Shape: (n_sensors, N*N, n_nodes, 3)
    
    if parameters['e_direction_sensor'] == 'sensor':
        e_sensor = a_s / LA.norm(a_s, axis=-1, keepdims=True)  # Shape: (n_sensors, 1 , 3)
        e_sensor=e_sensor[:,None,:]
    else:
        e_sensor = sensors / LA.norm(sensors, axis=-1, keepdims=True)  # Shape: (n_sensors, N*N, 3)
    
    L = np.sum(e_sensor[:,:, None, :] * R, axis=-1)  # Shape: (n_sensors, N*N, n_nodes)
    
    # --- 2.2 Integration ---
    ker_values=L
    
    integral = np.sum(ker_values * ddx * ddx, axis=1)  # Shape: (n_sensors, n_nodes)

    return (mu / (4 * np.pi)) * integral

##################################3
### Pizza device #############
##############################


# Let's created a class for the pizza device but adapted to the finite diferences 

class Device_Experiment_Cylinder_Parts_currents_all:
    '''this class create the basic structure of the new device orientated in the axis x, y or z'''
    def __init__(self , center, coils_parameters,parameters,psi,coordinates_nodes):
        '''initialize the device 
        center: center position of the device 
        orientation:'axis_coil's' might be oriented 'x', 'y' or 'z'
        coils_parameters: dictionary for the geometry of coils  helix  'num_segments_per_turn': ,'num_turns': in the ehlix of height h , 'axis' in which the coils will be oriented 
        '''
        #geometri of the device
        self.height = 2*1e-2 #height of the cylinder using as coils 
        self.sensor_coil_shift = 0.4*1e-2 #distance between the center of device to the sensors
        self.len_sensor = 1.4*1e-2 #len of the sensor
        self.sensor_shift = 0.03*1e-2 #distance betweeen the sensor to the ROI
        self.N = 14 #number of points in the sensor 

        self.coil_shift = 2.2*1e-2  #distance between the begining of of the coils /20*1e-2
        self.layer_size = 0.85*1e-2  #distance between the begining of of the coils


        # self.radio_initial = 2.5*1e-2 # diameter of the begining of the cylinder
        # self.radio_final = 4.4*1e-2  #diameter of the end of the cylinder after wiring


        self.coil_shift = 0.8*1e-2  #distance between the begining of of the coils /20*1e-2
        self.layer_size = 0.3*1e-2  #distance between the begining of of the coils
        self.radio_initial = 4.4*1e-2 # diameter of the begining of the cylinder
        self.radio_final = 5.0*1e-2  #diameter of the end of the cylinder after wiring


        self.coils_parameters = coils_parameters #parameter of the coils

        # Define the normal vector (outward-pointing from the cylinder surface) at the starting point
        normal_vector = center/ np.linalg.norm(center)
        # normal_vector = np.array([0, 1, 0])

        # Define the tangent vector (along the cylinder's circumference)
        self.tangent_vector = np.array([1, 0, 0])

        # Define the bitangent vector (perpendicular to the cylinder, outwards or inwards)
        bitangent_vector = np.cross(normal_vector, self.tangent_vector)
        self.bitangent_vector = bitangent_vector / np.linalg.norm(bitangent_vector)


        outside = np.cross(bitangent_vector,self.tangent_vector)
        self.outside = -1*outside/np.linalg.norm(outside)

        self.center = np.array(center)+self.sensor_shift *self.outside 


        self.sensor_start = self.center - (self.len_sensor/2)* self.tangent_vector 
        self.sensor_end = self.center + (self.len_sensor/2)* self.tangent_vector


        self.bitangent_norm_pos = (self.bitangent_vector)/np.linalg.norm(self.bitangent_vector)
        # Pre-calculate the axis vector
        axis_vector = self.tangent_vector

        # Pre-calculate sensor start and end points
        self.sensor_start_x = self.center - (self.len_sensor / 2) * axis_vector
        self.sensor_end_x = self.center + (self.len_sensor / 2) * axis_vector

        # Pre-calculate dsensor and dsensor_y *outside* the loops
        dsensor = (self.sensor_end_x - self.sensor_start_x) / self.N
        sub_sensor = [self.sensor_start_x + i * dsensor for i in range(self.N)]
        # print(np.array(sub_sensor))
        self.points_sensor = []
        for i in range(len(sub_sensor)):
            sensor_start_y_x = sub_sensor[i] - (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_start_y_x)
            sensor_end_y_x = sub_sensor[i] + (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_end_y_x)
            dsensor_y = (sensor_end_y_x-sensor_start_y_x)/self.N
            self.points_sensor.extend([sensor_start_y_x + j * dsensor_y for j in range(self.N)])

        self.ddx=self.len_sensor /self.N


        
        self.coils = self.calculate_coils()     #get the position of the points where the coils will be segmented

        self.Hv = self.magnetic_field_coils(coordinates_nodes) # get the magnetic field for each coil

        self.coil_current=np.array(self.coils_parameters['current'])
        
        self.u1 = self.Hv[0]+self.Hv[2]
        self.u2 = self.Hv[1]+self.Hv[3]

        H13_norm = np.linalg.norm(self.u1, axis=1)
        self.b_1 = self.coil_current[:,np.newaxis]*H13_norm/np.max(H13_norm)  #for multiply  all the currents for the first activation coils vn*bi

        H24_norm = np.linalg.norm(self.u2, axis=1)
        self.b_2 = self.coil_current[:,np.newaxis]*H24_norm/np.max(H24_norm)       #for multiply all the currents for the second activation coils vn*bi

        self.G_led_field_matrices = self.get_led_field_matrices(parameters,psi,coordinates_nodes)

    def calculate_coils(self):
        'get the position of the coils point where it will be segmented'
        
        coil_offsetx = self.coil_shift/2 * self.tangent_vector
        coil_offsety = self.coil_shift/2 * self.bitangent_vector
        coil_sensor_offset = self.sensor_coil_shift * self.outside

        center_coil1 = self.center + coil_offsetx + coil_sensor_offset
        center_coil2 = self.center + coil_offsety + coil_sensor_offset
        center_coil3 = self.center - coil_offsetx + coil_sensor_offset
        center_coil4 = self.center - coil_offsety + coil_sensor_offset

        coil_segment1 = self.get_coil_points(center_coil1,7/4*np.pi,9/4*np.pi)
        coil_segment2 = self.get_coil_points(center_coil2,1/4*np.pi,3/4*np.pi)
        coil_segment3 = self.get_coil_points(center_coil3,3/4*np.pi,5/4*np.pi)
        coil_segment4 = self.get_coil_points(center_coil4,5/4*np.pi,7/4*np.pi)

        return coil_segment1, coil_segment2, coil_segment3, coil_segment4

    
    def get_coil_points(self, center_coil,theta_start, theta_end):
        # start_time=time.time()
        num_segments_per_turn = self.coils_parameters['num_segments_per_turn']
        num_turns = self.coils_parameters['num_turns']
        num_layer_wired = self.coils_parameters['num_layer_wired']
        #diference between the center coil and the center of the device in the level of the coil 
        dif_center_coil_device = center_coil-(self.center+ self.sensor_coil_shift * self.outside)
        unit_d_c_coil_device = dif_center_coil_device/ np.linalg.norm(dif_center_coil_device)
        #vectoe where the coil ending wired
        # center_coil_final = center_coil - self.layer_size * unit_d_c_coil_device


        height = self.height
        step_radio_helix = np.linspace(0, 1, num_layer_wired)
        radios_helix = np.linspace(self.radio_initial, self.radio_final, num_layer_wired)
        centers_helix = center_coil - self.layer_size*step_radio_helix[:,np.newaxis]* unit_d_c_coil_device
      
        all_segments = []

        # Create segments for each layer
        for i in range(num_layer_wired):
            # Calculate the center for the current layer
            layer_center = centers_helix[i] + (i % 2) * height * self.outside


            theta = np.linspace(theta_start, theta_end, num_segments_per_turn , endpoint=True)
            h = np.linspace(0, ((-1) ** i) * height, 3*num_turns * num_segments_per_turn + 1)
            
            step_unit = np.linspace(0,1, num_segments_per_turn+1 , endpoint=True)
            
            point_c = layer_center + (radios_helix[i] * np.cos(theta)[:, np.newaxis] * self.tangent_vector) + (radios_helix[i] * np.sin(theta)[:, np.newaxis] * self.bitangent_vector) 
            position_i = point_c[0]-layer_center
            position_in=position_i/np.linalg.norm(position_i)

            position_f = layer_center-point_c[-1]
            position_fn=position_f/np.linalg.norm(position_f)

            point_y = point_c[-1]+np.linalg.norm(position_f)*step_unit[:,np.newaxis]*position_fn
            point_x = layer_center+np.linalg.norm(position_i)*step_unit[:,np.newaxis]*position_in
        
            point=np.concatenate((point_c,point_y[1:], point_x[1:]), axis=0)

            # Generate the helical path parameters
            segments=[]

            for j in range(num_turns):     
                # Use NumPy broadcasting for vectorized calculation
                start_points =point + (h[j*3*num_segments_per_turn:(j+1)*3*num_segments_per_turn, np.newaxis] * self.outside)
                
                points = list(zip(start_points[:-1], start_points[1:]))
                segments.extend(points)
                # Calculate coil points along the heli
            all_segments.extend(segments)
        # end_time = time.time()
        # print('coil',theta_start,theta_end,'time', end_time-start_time)
        return all_segments
    
    def save_to_csv(self, filename):
        # dsensor=(self.sensor_end-self.sensor_start)/self.N
        # sub_sensor = [self.sensor_start + i * dsensor for i in range(self.N)]
        coils_device1 = np.array(self.coils[0])[:, 0, :].tolist()+np.array(self.coils[1])[:, 0, :].tolist()+np.array(self.coils[2])[:, 0, :].tolist()+np.array(self.coils[3])[:, 0, :].tolist()#+sub_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')


    def save_to_csv_plate(self, filename):
        coils_device1 = self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')

    

    def get_led_field_matrices(self, parameters,psi,coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
        # print('sensor sensitve axis 1')
       

        fv1 = np.tanh(self.b_1/10) #evaluate the tanh  in the  current multiply by the normalized direction of magnetic field generated and multiply by lead matrix of 1 and 3 {0,2} 
        fv2 = np.tanh(self.b_2/10) #the same of fv1 but for coils 2 and 4 [1,3]

        G_coil_current = [] #  (number of currents , 8 matrices) matrices

        for i in range(fv1.shape[0]):
            G_coil_1= psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes, self.Hv[0],fv1[i])
            G_coil_2= psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes,  self.Hv[1],fv2[i])
            G_coil_3= psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes,  self.Hv[2],fv1[i])
            G_coil_4= psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes,  self.Hv[3],fv2[i])
        
            
            G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N ,
                                                                  [self.bitangent_norm_pos], coordinates_nodes,  self.Hv[0],fv1[i])
            G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                  [self.bitangent_norm_pos], coordinates_nodes,  self.Hv[1],fv2[i])
            G_coil_3_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                  [self.bitangent_norm_pos], coordinates_nodes,  self.Hv[2],fv1[i])
            G_coil_4_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                  [self.bitangent_norm_pos], coordinates_nodes,  self.Hv[3],fv2[i])
            G_coil_current.append([G_coil_1, G_coil_2, G_coil_3, G_coil_4, G_coil_1_b, G_coil_2_b, G_coil_3_b, G_coil_4_b])
       
        return G_coil_current
    

    def magnetic_field_coils(self,coordinates_nodes): 
        '''This function get the field matrices for the segmentations getting for the coils'''
       
        coil_current=1 
        Hv1=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[0], coil_current)
        Hv2=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[1], coil_current)
        Hv3=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[2], -coil_current)
        Hv4=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[3], -coil_current)
        return Hv1, Hv2,  Hv3, Hv4
    
    def solve_forward_model(self, G_coil_matrices, concentration1, same_time=True):
        '''solve the forward model for the simulation of the signals'''
        '''if the same_time is true the G_coil_matrices is must be sum firt otherwise the G_coils_matrices has to be composed by two matrices'''
        # G_coil_matrices=self.get_led_field_matrices()
        noise_v = np.random.normal(0, 1, 4)
        if same_time is True:
            V_coil = G_coil_matrices.dot(concentration1)
            epsilon = LA.norm(V_coil) / (10 * np.linalg.norm(noise_v))
            V_noise_coil = V_coil + epsilon * noise_v
            return V_noise_coil
        else:
            #for the first coil
            V_coil1_1 = G_coil_matrices[0].dot(concentration1)
            epsilon1 = LA.norm(V_coil1_1) / (10 * np.linalg.norm(noise_v[0]))
            V_noise_coil1_1 = V_coil1_1 + epsilon1 * noise_v[0]

            #for the second coil
            V_coil2_1 = G_coil_matrices[1].dot(concentration1)
            epsilon2 = LA.norm(V_coil2_1) / (10 * np.linalg.norm(noise_v[1]))
            V_noise_coil2_1= V_coil2_1 + epsilon2 * noise_v[1]
            return V_noise_coil1_1,V_noise_coil2_1


class pizza_cylinder_coils_DF:
    '''This class simulate an experiment for the cube with devices located in the border '''
    def __init__(self, sensors,parameters_coil_device, current_coils,parameters,psi,coordinates_nodes):
        '''This class calculate the matrix associated for multiple currents for every device compuse by 2 coils which are excitated at the same time '''
        self.parameters_coil_device = parameters_coil_device
        self.current_coils = current_coils
        self.V_signals_sensor_current = []
        # current_coils=[7, 0.5, 0.7, 0.9, 1.27, 5, 2, 3]


        self.V_total_noise_current = []
        self.Dev_x = [] #list class of the device for each sensor 
        self.G_x = []  #list of the number_sensors  list of number_currents matrices (order 4 by nodes)
        self.G_total_current = [] #list of matrices concatanete for each sensor 
        self.sensors=sensors
        self.coordinates_nodes = coordinates_nodes

        self.parameters = parameters
        self.psi = psi

    def compute_G_devices(self):
        self.parameters_coil_device['current'] = self.current_coils
        devices_x = [Device_Experiment_Cylinder_Parts_currents_all(self.sensors[i],self.parameters_coil_device,self.parameters,self.psi,self.coordinates_nodes) for i in range(len(self.sensors))]
        self.Dev_x = devices_x
        for i in range(len(devices_x)):
            G_devices_x = [np.concatenate(([np.sum((devices_x[i].G_led_field_matrices[j][0],devices_x[i].G_led_field_matrices[j][2]), axis=0), #acivativa the first 2 non neighboors at the same time at 1 sensitive axis
                            np.sum((devices_x[i].G_led_field_matrices[j][1],devices_x[i].G_led_field_matrices[j][3]), axis=0),  #acivativa  the second 2 non neighboors at the same time at 1 sensitive axis
                            np.sum((devices_x[i].G_led_field_matrices[j][4],devices_x[i].G_led_field_matrices[j][6]), axis=0),  #acivativa the first 2 non neighboors at the same time at 2 sensitive axis
                            np.sum((devices_x[i].G_led_field_matrices[j][5],devices_x[i].G_led_field_matrices[j][7]), axis=0),  #acivativa the second 2 non neighboors at the same time at 2 sensitive axis
                            ]),axis=0)  for j in range(len(self.current_coils))] #4 measure by currents coils
            self.G_x.append(G_devices_x)
            G_total_x = np.concatenate(G_devices_x, axis=0) #concatenate all the currents
            # print(G_total_x.shape)
            self.G_total_current.append(G_total_x) #add for the matrix of the new position sensor

        G_global1 = np.concatenate(self.G_total_current, axis=0) #concatenate the total for all the positions of the sensors
        return G_global1
    
    def compute_V_total_noise(self, concentration):
        self.V_total_noise_current = []
        for k in range(len(self.Dev_x)):
            # print(k)
            V_noise_devices_x = [self.Dev_x[k].solve_forward_model(self.G_x[k][i], concentration) for i in range(len(self.current_coils))]
            self.V_signals_sensor_current.append(V_noise_devices_x)
            V_total_noise_x = np.concatenate(V_noise_devices_x, axis=0)
            self.V_total_noise_current.append(V_total_noise_x)
        V_global1 = np.concatenate(self.V_total_noise_current, axis=0)
        return V_global1
    

    def plot_all_sensors(self, index_sensor):
        sensors_points=[]
        for i in index_sensor:
            sensors_points.extend(self.Dev_x[i].points_sensor)
        return sensors_points


    def plot_n_device_some_coils(self, index_sensor):
        coils_points=[]
        for i in index_sensor:
            coils_device1 = np.array(self.Dev_x[i].coils[0])[:, 0, :].tolist()+np.array(self.Dev_x[i].coils[1])[:, 0, :].tolist()+np.array(self.Dev_x[i].coils[2])[:, 0, :].tolist()+np.array(self.Dev_x[i].coils[3])[:, 0, :].tolist()
        
            coils_points.extend(np.array(coils_device1))
        return coils_points



################################
## device with two coils #######
## old geometry ###
################################


class Device_Experiment_Cylinder_all_currents:
    '''this class create the basic structure of the new device orientated in the axis x, y or z'''
    def __init__(self , center, coils_parameters, parameters,psi,coordinates_nodes, coils_aling_direction = None):
        '''initialize the device 
        center: center position of the device 
        orientation:'axis_coil's' might be oriented 'x', 'y' or 'z'
        coils_parameters: dictionary for the geometry of coils  helix  'num_segments_per_turn': ,'num_turns': in the ehlix of height h , 'axis' in which the coils will be oriented 
        coils_aling_direction: list of basisof the  plane where the divice is aling , the [0] component is where the coils are aling , [1] component of the wall, [2] sign for outs
        '''
        #geometri of the device
        self.height = 2*1e-2 #height of the cylinder using as coils 
        self.sensor_coil_shift = 0.4*1e-2 #distance between the center of device to the sensors
        self.len_sensor = 1.4*1e-2
        self.sensor_shift = 0.03*1e-2
        self.N=14 #number of points in the sensor 

        self.coil_shift = 4.5*1e-2  #distance between the centers of of the coils 
        self.a_initial = 2.5*1e-2 # diameter of the begining of the cylinder
        self.a_final = 4.4*1e-2  #diameter of the end of the cylinder after wiring

        self.coils_parameters = coils_parameters #parameter of the coils

        # Define the normal vector (outward-pointing from the cylinder surface) at the starting point
        normal_vector = center/ np.linalg.norm(center)
        # normal_vector = np.array([0, 1, 0])

        # Define the tangent vector (along the cylinder's circumference)
        if coils_aling_direction == None:
            self.tangent_vector = np.array([1, 0, 0])
            self.bitangent_vector = np.array([0, 1, 0])
            self.out_sign = -1

        else:
            self.tangent_vector = coils_aling_direction[0]
            self.bitangent_vector = coils_aling_direction[1]
            self.out_sign = coils_aling_direction[2]
        
        

        # # Define the bitangent vector (perpendicular to the cylinder, outwards or inwards)
        # bitangent_vector = np.cross(normal_vector, self.tangent_vector)
        # self.bitangent_vector = bitangent_vector / np.linalg.norm(bitangent_vector)
        outside = np.cross(self.bitangent_vector,self.tangent_vector)
        self.outside = np.abs(outside)/np.linalg.norm(outside)*self.out_sign


        self.center = np.array(center)+self.sensor_shift *self.outside 
        self.sensor_start = self.center - (self.len_sensor/2)* self.tangent_vector 
        self.sensor_end = self.center + (self.len_sensor/2)* self.tangent_vector


        self.bitangent_norm_pos = (self.bitangent_vector)/np.linalg.norm(self.bitangent_vector)
        # Pre-calculate the axis vector
        axis_vector = self.tangent_vector

        # Pre-calculate sensor start and end points
        self.sensor_start_x = self.center - (self.len_sensor / 2) * axis_vector
        self.sensor_end_x = self.center + (self.len_sensor / 2) * axis_vector

        # Pre-calculate dsensor and dsensor_y *outside* the loops
        dsensor = (self.sensor_end_x - self.sensor_start_x) / self.N
        sub_sensor = [self.sensor_start_x + i * dsensor for i in range(self.N)]
        # print(np.array(sub_sensor))
        self.points_sensor = []
        for i in range(len(sub_sensor)):
            sensor_start_y_x = sub_sensor[i] - (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_start_y_x)
            sensor_end_y_x = sub_sensor[i] + (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_end_y_x)
            dsensor_y = (sensor_end_y_x-sensor_start_y_x)/self.N
            self.points_sensor.extend([sensor_start_y_x + j * dsensor_y for j in range(self.N)])

        self.ddx=self.len_sensor /self.N

        self.coils = self.calculate_coils()     #get the position of the points where the coils will be segmented   
        
        self.Hv = self.magnetic_field_coils(coordinates_nodes) # get the magnetic field for each coil

        # self.coil_current=self.coils_parameters['current'] 
        self.coil_current=np.array(self.coils_parameters['current'])
        
        self.u1 = self.Hv[0]+self.Hv[1]
        # self.u2 = self.Hv[1]+self.Hv[3]

        H12_norm = np.linalg.norm(self.u1, axis=1)
        '''here is the difference'''
        self.b_1 = self.coil_current[:,np.newaxis]*H12_norm/np.max(H12_norm)  #for multiply the current for the activation coils vn*bi

        self.G_led_field_matrices = self.get_led_field_matrices(parameters,psi,coordinates_nodes) 


    

    def calculate_coils(self):
        'get the position of the coils point where it will be segmented'
            
        coil_offset = self.coil_shift/2 * self.tangent_vector
        coil_sensor_offset = self.sensor_coil_shift * self.outside

        center_coil1 = self.center + coil_offset + coil_sensor_offset
        center_coil2 = self.center - coil_offset + coil_sensor_offset

        coil_segment1 = self.get_coil_points(center_coil1)
        coil_segment2 = self.get_coil_points(center_coil2)
        # coil_segment2 = coil_segment1 - 2*coil_offset

        return coil_segment1, coil_segment2 

    
    def get_coil_points(self, center_coil):
        num_segments_per_turn = self.coils_parameters['num_segments_per_turn']
        num_turns = self.coils_parameters['num_turns']
        num_layer_wired = self.coils_parameters['num_layer_wired']

        height = self.height
        radios_helix = np.linspace(self.a_initial/2, self.a_final / 2, num_layer_wired)

        all_segments = []

        # Create segments for each layer
        for i in range(num_layer_wired):
            # Calculate the center for the current layer
            layer_center = center_coil + (i % 2) * height * self.outside
            # Generate the helical path parameters
            theta = np.linspace(0, 2 * np.pi * num_turns, num_turns * num_segments_per_turn + 1, endpoint=True)
            h = np.linspace(0, ((-1) ** i) * height, num_turns * num_segments_per_turn + 1)

            # Calculate coil points along the helix

            # Use NumPy broadcasting for vectorized calculation
            start_points = layer_center + (radios_helix[i] * np.cos(theta)[:, np.newaxis] * self.tangent_vector) + (radios_helix[i] * np.sin(theta)[:, np.newaxis] * self.bitangent_vector) + (h[:, np.newaxis] * self.outside)
            all_segments.extend(list(zip(start_points[:-1], start_points[1:])))

        return all_segments
    

    def save_to_csv(self, filename):

        coils_device1 = np.array(self.coils[0])[:, 0, :].tolist()+np.array(self.coils[1])[:, 0, :].tolist()+self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')

    def save_to_csv_plate(self, filename):
        coils_device1 = self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')


    def get_led_field_matrices(self, parameters,psi,coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
    
        # a_s = -1*self.outside

        fv1 = np.tanh(self.b_1/10)  
        G_coil_current = []

        for i in range(fv1.shape[0]):
            G_coil_1 = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes, self.Hv[0],fv1[i])
            G_coil_2 = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes,  self.Hv[1],fv1[i])
            G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                [self.bitangent_norm_pos], coordinates_nodes, self.Hv[0],fv1[i])
            G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                  [self.bitangent_norm_pos], coordinates_nodes, self.Hv[1],fv1[i])
            G_coil_current.append([G_coil_1, G_coil_2,G_coil_1_b, G_coil_2_b])

        return G_coil_current
    

    def magnetic_field_coils(self, coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
        # coil_current=self.coils_parameters['current'] 
        coil_current = 1   
        Hv1=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[0], coil_current)
        Hv2=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[1], -coil_current)
        return Hv1, Hv2
    
    def solve_forward_model(self, G_coil_matrices, concentration1, same_time=True):
        '''solve the forward model for the simulation of the signals'''
        '''if the same_time is true the G_coil_matrices is must be sum firt otherwise the G_coils_matrices has to be composed by two matrices'''
        # G_coil_matrices=self.get_led_field_matrices()
        noise_v = np.random.normal(0, 1, 2)
        if same_time is True:
            V_coil = G_coil_matrices.dot(concentration1)
            epsilon = LA.norm(V_coil) / (10 * np.linalg.norm(noise_v))
            V_noise_coil = V_coil + epsilon * noise_v
            return V_noise_coil
        else:
            #for the first coil
            V_coil1_1 = G_coil_matrices[0].dot(concentration1)
            epsilon1 = LA.norm(V_coil1_1) / (10 * np.linalg.norm(noise_v[0]))
            V_noise_coil1_1 = V_coil1_1 + epsilon1 * noise_v[0]

            #for the second coil
            V_coil2_1 = G_coil_matrices[1].dot(concentration1)
            epsilon2 = LA.norm(V_coil2_1) / (10 * np.linalg.norm(noise_v[1]))
            V_noise_coil2_1= V_coil2_1 + epsilon2 * noise_v[1]
            return V_noise_coil1_1,V_noise_coil2_1





class two_cylinder_coils_DF:
    '''This class simulate an experiment for the cube with devices located in the border '''
    def __init__(self, sensors,parameters_coil_device, current_coils,parameters,psi,coordinates_nodes, coils_aling_direction=None):
        '''This class calculate the matrix associated for multiple currents for every device compuse by 2 coils which are excitated at the same time '''
        self.parameters_coil_device = parameters_coil_device
        self.current_coils = current_coils
        self.V_signals_sensor_current = []  #list of number_sensor lists of sesorsignals for each current 
        # current_coils=[7, 0.5, 0.7, 0.9, 1.27, 5, 2, 3]
        self.G_total_current = []
        self.V_total_noise_current = []
        self.Dev_x = []
        self.G_x = []
        self.sensors=sensors

        self.coils_aling_direction=coils_aling_direction
        self.parameters = parameters
        self.psi = psi
        self.coordinates_nodes = coordinates_nodes


           
    def compute_G_devices(self):
        self.parameters_coil_device['current'] = self.current_coils
        devices_x = [Device_Experiment_Cylinder_all_currents(self.sensors[i],self.parameters_coil_device,self.parameters,self.psi,self.coordinates_nodes, self.coils_aling_direction) for i in range(len(self.sensors))]
        self.Dev_x = devices_x
        for i in range(len(devices_x)):
            G_devices_x = [np.concatenate(([np.sum((devices_x[i].G_led_field_matrices[j][0], devices_x[i].G_led_field_matrices[j][1]), axis=0),
                           np.sum((devices_x[i].G_led_field_matrices[j][2], devices_x[i].G_led_field_matrices[j][3]), 
                                  axis=0)]),axis=0)
                            for j in range(len(self.current_coils))]
            self.G_x.append(G_devices_x)
            G_total_x = np.concatenate(G_devices_x, axis=0)
            # print(G_total_x)
            self.G_total_current.append(G_total_x)

        G_global1 = np.concatenate(self.G_total_current, axis=0)
        return G_global1

    def compute_V_total_noise(self, concentration):
        self.V_total_noise_current = []
        for k in range(len(self.Dev_x)):
            V_noise_devices_x = [self.Dev_x[k].solve_forward_model(self.G_x[k][i], concentration) for i in range(len(self.current_coils))]
            self.V_signals_sensor_current.append(V_noise_devices_x)
            V_total_noise_x = np.concatenate(V_noise_devices_x, axis=0)
            self.V_total_noise_current.append(V_total_noise_x)
        V_global1 = np.concatenate(self.V_total_noise_current, axis=0)
        return V_global1
    
    def plot_all_sensors_pv(self, index_sensor):
        sensors_points=[]
        for i in index_sensor:
            sensors_points.extend(self.Dev_x[i].points_sensor)
        return sensors_points


    def plot_n_device_some_coils_pv(self, index_sensor):
        coils_points=[]
        for i in index_sensor:
            coils_device1 = np.array(self.Dev_x[i].coils[0])[:, 0, :].tolist()+np.array(self.Dev_x[i].coils[1])[:, 0, :].tolist()
            coils_points.extend(np.array(coils_device1))
        return coils_points





    def plot_all_sensors(self, filename):
        self.sensors_points=[]
        for i in range(len(self.sensors)):
            self.sensors_points.extend(self.Dev_x[i].points_sensor)
        np.savetxt(filename,  self.sensors_points, delimiter=',', header='x,y,z', comments='')

    def plot_n_sensor(self, n_sensor, filename):
        self.Dev_x[n_sensor].save_to_csv_plate(filename)

    def plot_n_device(self, n_pizza,filename):
        self.Dev_x[n_pizza].save_to_csv(filename)

    
##################################################################
################################
## device with two coils #######
################################
###################################################################
##############
##################################################################
#################################################################################
################## The most important for the experiment ##############################
################## Channel -0 closest to the cube ############################
##########################################################
################################################################################




class Cube_new_dimentions:
    '''this class create the basic structure of the new device orientated in the axis x, y or z'''
    def __init__(self , center, coils_parameters, parameters,psi,coordinates_nodes, N,coils_aling_direction = None, saturation = True, sensitive_funct = None):
        '''initialize the device 
        center: center position of the device 
        orientation:'axis_coil's' might be oriented 'x', 'y' or 'z'
        coils_parameters: dictionary for the geometry of coils  helix  'num_segments_per_turn': ,'num_turns': in the ehlix of height h , 'axis' in which the coils will be oriented 
        coils_aling_direction: list of basisof the  plane where the divice is aling , the [0] component is where the coils are aling , [1] component of the wall, [2] sign for outs
        '''
        #geometri of the device
        self.height = 2*1e-2 #height of the cylinder using as coils 
        self.sensor_coil_shift = 0.4*1e-2 #distance between the center of device to the sensors
        self.len_sensor = 1.4*1e-2
        self.sensor_shift = 0.03*1e-2
        self.N=N #number of points in the sensor 

        self.coil_shift = 4.4*1e-2  #distance between the centers of of the coils 
        self.a_initial = 2.5*1e-2 # diameter of the begining of the cylinder
        self.a_final = 4.2*1e-2  #diameter of the end of the cylinder after wiring

        self.coils_parameters = coils_parameters #parameter of the coils

        self.saturation = saturation

        # Define the normal vector (outward-pointing from the cylinder surface) at the starting point
  


        # Define the tangent vector (along the cylinder's circumference)
        if coils_aling_direction is None:
            self.tangent_vector = np.array([1, 0, 0])
            self.bitangent_vector = np.array([0, 1, 0])
            self.out_sign = -1

        else:
            self.tangent_vector = coils_aling_direction[0]
            self.bitangent_vector = coils_aling_direction[1]
            self.out_sign = coils_aling_direction[2]
        
        

        # # Define the bitangent vector (perpendicular to the cylinder, outwards or inwards)
        # bitangent_vector = np.cross(normal_vector, self.tangent_vector)
        # self.bitangent_vector = bitangent_vector / np.linalg.norm(bitangent_vector)
        outside = np.cross(self.bitangent_vector,self.tangent_vector)
        self.outside = np.abs(outside)/np.linalg.norm(outside)*self.out_sign


        self.center = np.array(center)+self.sensor_shift *self.outside 
        # self.sensor_start = self.center - (self.len_sensor/2)* self.tangent_vector 
        # self.sensor_end = self.center + (self.len_sensor/2)* self.tangent_vector


        self.bitangent_norm_pos = (self.bitangent_vector)/np.linalg.norm(self.bitangent_vector)
        # Pre-calculate the axis vector
        axis_vector = self.tangent_vector

        # Pre-calculate sensor start and end points
        self.sensor_start_x = self.center - (self.len_sensor / 2) * axis_vector
        self.sensor_end_x = self.center + (self.len_sensor / 2) * axis_vector


        self.ddx=self.len_sensor /self.N
        # Pre-calculate dsensor and dsensor_y *outside* the loops
        dsensor = (self.sensor_end_x - self.sensor_start_x) / self.N
        sub_sensor = [self.sensor_start_x + i * dsensor + (self.ddx  / 2) * axis_vector for i in range(self.N)]
        # print(np.array(sub_sensor))
        self.points_sensor = []
        for i in range(len(sub_sensor)):
            sensor_start_y_x = sub_sensor[i] - (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_start_y_x)
            sensor_end_y_x = sub_sensor[i] + (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_end_y_x)
            dsensor_y = (sensor_end_y_x-sensor_start_y_x)/self.N
            self.points_sensor.extend([sensor_start_y_x + j * dsensor_y + (self.ddx/2)*self.bitangent_norm_pos for j in range(self.N)])




        

        

        self.coils = self.calculate_coils()     #get the position of the points where the coils will be segmented   
        
        self.Hv = self.magnetic_field_coils(coordinates_nodes) # get the magnetic field for each coil

        # self.coil_current=self.coils_parameters['current'] 
        self.coil_current=np.array(self.coils_parameters['current'])
        
        self.u1 = self.Hv[0]+self.Hv[1]
        # self.u2 = self.Hv[1]+self.Hv[3]

        H12_norm = np.linalg.norm(self.u1, axis=1)


        self.u1_norm = H12_norm[:,np.newaxis]
        '''here is the difference'''
        #indenpendence of the current on voxels
        self.b_1 = self.coil_current[:,np.newaxis]*H12_norm/np.max(H12_norm)  #for multiply the current for the activation coils vn*bi
        #indenpendence of the current on voxels
        self.b_2 = self.coil_current
        self.sensitive_function = sensitive_funct
        self.G_led_field_matrices = self.get_led_field_matrices(parameters,psi,coordinates_nodes) 


    

    def calculate_coils(self):
        'get the position of the coils point where it will be segmented'
            
        coil_offset = self.coil_shift/2 * self.tangent_vector
        coil_sensor_offset = self.sensor_coil_shift * self.outside

        center_coil1 = self.center + coil_offset + coil_sensor_offset
        center_coil2 = self.center - coil_offset + coil_sensor_offset

        coil_segment1 = self.get_coil_points(center_coil1)
        coil_segment2 = self.get_coil_points(center_coil2)
        # coil_segment2 = coil_segment1 - 2*coil_offset

        return coil_segment1, coil_segment2 

    
    def get_coil_points(self, center_coil):
        num_segments_per_turn = self.coils_parameters['num_segments_per_turn']
        num_turns = self.coils_parameters['num_turns']
        num_layer_wired = self.coils_parameters['num_layer_wired']

        height = self.height
        radios_helix = np.linspace(self.a_initial/2, self.a_final / 2, num_layer_wired)

        all_segments = []

        # Create segments for each layer
        for i in range(num_layer_wired):
            # Calculate the center for the current layer
            layer_center = center_coil + (i % 2) * height * self.outside
            # Generate the helical path parameters
            theta = np.linspace(0, 2 * np.pi * num_turns, num_turns * num_segments_per_turn + 1, endpoint=True)
            h = np.linspace(0, ((-1) ** i) * height, num_turns * num_segments_per_turn + 1)

            # Calculate coil points along the helix

            # Use NumPy broadcasting for vectorized calculation
            start_points = layer_center + (radios_helix[i] * np.cos(theta)[:, np.newaxis] * self.tangent_vector) + (radios_helix[i] * np.sin(theta)[:, np.newaxis] * (self.bitangent_vector)) + (h[:, np.newaxis] * self.outside)
            all_segments.extend(list(zip(start_points[:-1], start_points[1:])))

        return all_segments
    

    def save_to_csv(self, filename):

        coils_device1 = np.array(self.coils[0])[:, 0, :].tolist()+np.array(self.coils[1])[:, 0, :].tolist()+self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')

    def save_to_csv_plate(self, filename):
        coils_device1 = self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')


    def get_led_field_matrices(self, parameters,psi,coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
    
        # a_s = -1*self.outside

        fv1 = np.tanh(self.b_1/10)  
        G_coil_current = []

        for i in range(fv1.shape[0]):
            if self.saturation:
                G_coil_1 = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes, self.Hv[0]/self.u1_norm,fv1[i],function_sensitive = self.sensitive_function )
                G_coil_2 = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes,  self.Hv[1]/self.u1_norm,fv1[i],function_sensitive = self.sensitive_function)
                G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.Hv[0]/self.u1_norm,fv1[i],function_sensitive = self.sensitive_function)
                G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.Hv[1]/self.u1_norm,fv1[i],function_sensitive = self.sensitive_function)
            else:
                G_coil_1 = psi * lead_field_matrix_coil_Hv_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes, self.b_2*self.Hv[0]/self.u1_norm,function_sensitive = self.sensitive_function)
                G_coil_2 = psi * lead_field_matrix_coil_Hv_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes,  self.b_2*self.Hv[1]/self.u1_norm,function_sensitive = self.sensitive_function)
                G_coil_1_b = psi * lead_field_matrix_coil_Hv_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.b_2*self.Hv[0]/self.u1_norm,function_sensitive = self.sensitive_function)
                G_coil_2_b = psi * lead_field_matrix_coil_Hv_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.b_2*self.Hv[1]/self.u1_norm,function_sensitive = self.sensitive_function)

            G_coil_current.append([G_coil_1, G_coil_2,G_coil_1_b, G_coil_2_b])

        return G_coil_current
    

    def magnetic_field_coils(self, coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
        # coil_current=self.coils_parameters['current'] 
        coil_current = 1   
        Hv1=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[0], coil_current)
        Hv2=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[1], -coil_current)
        return Hv1, Hv2
    


    def solve_forward_model(self, G_coil_matrices, concentration1, same_time=True):
        '''solve the forward model for the simulation of the signals'''
        '''if the same_time is true the G_coil_matrices is must be sum firt otherwise the G_coils_matrices has to be composed by two matrices'''
        # G_coil_matrices=self.get_led_field_matrices()
        noise_v = np.random.normal(0, 1, 2)
        if same_time is True:
            V_coil = G_coil_matrices.dot(concentration1)
            epsilon = LA.norm(V_coil) / (10 * np.linalg.norm(noise_v))
            V_noise_coil = V_coil + epsilon * noise_v
            return V_noise_coil
        else:
            #for the first coil
            V_coil1_1 = G_coil_matrices[0].dot(concentration1)
            epsilon1 = LA.norm(V_coil1_1) / (10 * np.linalg.norm(noise_v[0]))
            V_noise_coil1_1 = V_coil1_1 + epsilon1 * noise_v[0]

            #for the second coil
            V_coil2_1 = G_coil_matrices[1].dot(concentration1)
            epsilon2 = LA.norm(V_coil2_1) / (10 * np.linalg.norm(noise_v[1]))
            V_noise_coil2_1= V_coil2_1 + epsilon2 * noise_v[1]
            return V_noise_coil1_1,V_noise_coil2_1







class new_dimentions_two_cylinder_coils_DF:
    '''This class simulate an experiment for the cube with devices located in the border '''
    def __init__(self, sensors,parameters_coil_device, current_coils,parameters,psi,coordinates_nodes,N, coils_aling_direction=None, saturation = True, sensitive_f = None):
        '''This class calculate the matrix associated for multiple currents for every device compuse by 2 coils which are excitated at the same time '''
        self.parameters_coil_device = parameters_coil_device
        self.current_coils = current_coils
        self.V_signals_sensor_current = []  #list of number_sensor lists of sesorsignals for each current 
        # current_coils=[7, 0.5, 0.7, 0.9, 1.27, 5, 2, 3]
        self.G_total_current = []
        self.V_total_noise_current = []
        self.Dev_x = []
        self.G_x = []
        self.sensors=sensors

        self.coils_aling_direction=coils_aling_direction
        self.parameters = parameters
        self.psi = psi
        self.coordinates_nodes = coordinates_nodes
        self.saturation = saturation 
        self.sensitive_f = sensitive_f
        self.N = N #discretization of 

           
    def compute_G_devices(self):
        self.parameters_coil_device['current'] = self.current_coils
        devices_x = [Cube_new_dimentions(self.sensors[i],self.parameters_coil_device,self.parameters,self.psi,self.coordinates_nodes,self.N ,self.coils_aling_direction, self.saturation, sensitive_funct = self.sensitive_f) for i in range(len(self.sensors))]
        self.Dev_x = devices_x
        for i in range(len(devices_x)):
            G_devices_x = [np.concatenate(([np.sum((devices_x[i].G_led_field_matrices[j][0], devices_x[i].G_led_field_matrices[j][1]), axis=0),
                           np.sum((devices_x[i].G_led_field_matrices[j][2], devices_x[i].G_led_field_matrices[j][3]), 
                                  axis=0)]),axis=0)
                            for j in range(len(self.current_coils))]
            self.G_x.append(G_devices_x)
            G_total_x = np.concatenate(G_devices_x, axis=0)
            # print(G_total_x)
            self.G_total_current.append(G_total_x)

        G_global1 = np.concatenate(self.G_total_current, axis=0)
        return G_global1

    def compute_V_total_noise(self, concentration):
        self.V_total_noise_current = []
        for k in range(len(self.Dev_x)):
            V_noise_devices_x = [self.Dev_x[k].solve_forward_model(self.G_x[k][i], concentration) for i in range(len(self.current_coils))]
            self.V_signals_sensor_current.append(V_noise_devices_x)
            V_total_noise_x = np.concatenate(V_noise_devices_x, axis=0)
            self.V_total_noise_current.append(V_total_noise_x)
        V_global1 = np.concatenate(self.V_total_noise_current, axis=0)
        return V_global1
    
    def plot_all_sensors_pv(self, index_sensor):
        sensors_points=[]
        for i in index_sensor:
            sensors_points.extend(self.Dev_x[i].points_sensor)
        return sensors_points


    def plot_n_device_some_coils_pv(self, index_sensor):
        coils_points=[]
        for i in index_sensor:
            coils_device1 = np.array(self.Dev_x[i].coils[0])[:, 0, :].tolist()+np.array(self.Dev_x[i].coils[1])[:, 0, :].tolist()
            coils_points.extend(np.array(coils_device1))
        return coils_points





    def plot_all_sensors(self, filename):
        self.sensors_points=[]
        for i in range(len(self.sensors)):
            self.sensors_points.extend(self.Dev_x[i].points_sensor)
        np.savetxt(filename,  self.sensors_points, delimiter=',', header='x,y,z', comments='')

    def plot_n_sensor(self, n_sensor, filename):
        self.Dev_x[n_sensor].save_to_csv_plate(filename)

    def plot_n_device(self, n_pizza,filename):
        self.Dev_x[n_pizza].save_to_csv(filename)








################################################################################
##################################################################
#################################################################################
################## The most important for the experiment ##############################
################## Channel -1 closest to the cube ############################
##########################################################
################################################################################
##################################################################



def lead_field_matrix_coil_Hv_fn_DF_abs(parameters,points,ddx, N, a_s, coordinates_nodes,Hv,fn_i, function_sensitive=None):
    """
    here it works for fn_i with saturation 
    IT MIGHT ONLY WORKS FOR ONE SENSOR AT TIME
    **check the reshape of the points, but for the moment it works for only one sensor which are interested

    Computes the lead field matrix for a coil using vectorized operations for efficiency.

    This function is for Difference finites it is an adaptation of the function for FEM lead_field_matrix_coil_fast3_Hv_fn

    Parameters:
    - parameters (dict): Dictionary of parameters, including 'e_direction_sensor' and 'mu'.
   
    - ddx 
    - N (int): Number of discretization points for each size of the plate sensors .
    - ddx: size of the discretization of each plate sensor size
    - points: array  of the discretization points in each plate sensor  
    - a_s (np.ndarray): Array of sensor orientations (shape: (n_sensors, 3)).
    - basis_function_test: Finite element test function (needed for assemble).
    - H_v magnetic field generated by coil_segments and  coil_current 
    - a_s is the sensitive axis of the sensor 

    Returns:
    np.ndarray: Lead field matrix (shape: (n_sensors, n_nodes)).
    """
    mu = parameters['mu']

    # array of the point for eac sensosr
    sensors = points.reshape(1,len(points), 3)

    # print(x_min, x_max )
    # print(sensors)
    # sensors = np.tile(sensors, (n_sensors, 1, 1))
    # print(sensors.shape)
    # --- 2.1 Vectorized ker_R_si_coil Calculation ---
    r = coordinates_nodes[None, None, :, :] - sensors[:, :, None, :]  # Shape: (n_sensors, N*N, n_nodes, 3)
    e_coil = Hv[None, None, :, :]  # Shape: (1, 1, n_nodes, 3)
    norm_r = LA.norm(r, axis=-1, keepdims=True)  # Shape: (n_sensors, N*N, n_nodes, 1)
    
    R = (3 * r * np.sum(e_coil * r, axis=-1, keepdims=True)) / (norm_r ** 5) - e_coil / (norm_r ** 3)  # Shape: (n_sensors, N*N, n_nodes, 3)
    
    

    if parameters['e_direction_sensor'] == 'sensor':
        e_sensor = a_s / np.linalg.norm(a_s, axis=-1, keepdims=True)  # Shape: (n_sensors, 1 , 3)
        e_sensor=e_sensor[:,None,:]
    else:
        e_sensor = sensors / np.linalg.norm(sensors, axis=-1, keepdims=True)  # Shape: (n_sensors, N*N, 3)
    
    L = np.sum(e_sensor[:,:, None, :] * R, axis=-1)  # Shape: (n_sensors, N*N, n_nodes)
    
    
    # --- 2.2 Integration ---
    if function_sensitive is None:
        ker_values=L
    else:
        sensitive_inf = function_sensitive[np.newaxis,:,np.newaxis]*L
        ker_values=sensitive_inf


    integral = fn_i[:np.newaxis]*np.sum(np.abs(ker_values) * ddx * ddx, axis=1)  #np.abs(ker_values) Shape: (n_sensors, n_nodes)


    return (mu / (4 * np.pi)) * integral










class Cube_new_dimentions_channel1:
    '''this class create the basic structure of the new device orientated in the axis x, y or z'''
    def __init__(self , center, coils_parameters, parameters,psi,coordinates_nodes,N , R_sensor=None, coils_aling_direction = None, saturation = True, channel_1 = False, func_saturation = np.tanh):
        '''initialize the device 
        center: center position of the device 
        orientation:'axis_coil's' might be oriented 'x', 'y' or 'z'
        coils_parameters: dictionary for the geometry of coils  helix  'num_segments_per_turn': ,'num_turns': in the ehlix of height h , 'axis' in which the coils will be oriented 
        coils_aling_direction: list of basisof the  plane where the divice is aling , the [0] component is where the coils are aling , [1] component of the wall, [2] sign for outs
        '''
        #geometri of the device
        self.height = 2*1e-2 #height of the cylinder using as coils 
        self.sensor_coil_shift = 0.4*1e-2 #distance between the center of device to the sensors
        self.len_sensor = 1.4*1e-2
        self.sensor_shift = 0.03*1e-2
        self.N=N #number of points in the sensor 

        self.coil_shift = 4.4*1e-2  #distance between the centers of of the coils 
        self.a_initial = 2.5*1e-2 # diameter of the begining of the cylinder
        self.a_final = 4.2*1e-2  #diameter of the end of the cylinder after wiring

        self.coils_parameters = coils_parameters #parameter of the coils

        self.saturation = saturation
        self.func_saturation = func_saturation 

        

        # Define the normal vector (outward-pointing from the cylinder surface) at the starting point
  


        # Define the tangent vector (along the cylinder's circumference)
        if coils_aling_direction == None:
            self.tangent_vector = np.array([1, 0, 0])
            self.bitangent_vector = np.array([0, 1, 0])
            self.out_sign = -1

        else:
            self.tangent_vector = coils_aling_direction[0]
            self.bitangent_vector = coils_aling_direction[1]
            self.out_sign = coils_aling_direction[2]
        
        

        # # Define the bitangent vector (perpendicular to the cylinder, outwards or inwards)
        # bitangent_vector = np.cross(normal_vector, self.tangent_vector)
        # self.bitangent_vector = bitangent_vector / np.linalg.norm(bitangent_vector)
        outside = np.cross(self.bitangent_vector,self.tangent_vector)
        self.outside = np.abs(outside)/np.linalg.norm(outside)*self.out_sign


        self.center = np.array(center)+self.sensor_shift *self.outside 
        
        # self.sensor_start = self.center - (self.len_sensor/2)* self.tangent_vector 
        # self.sensor_end = self.center + (self.len_sensor/2)* self.tangent_vector






        self.bitangent_norm_pos = (self.bitangent_vector)/np.linalg.norm(self.bitangent_vector)
        # Pre-calculate the axis vector
        axis_vector = self.tangent_vector


        self.ddx=self.len_sensor /(self.N)

        # Pre-calculate sensor start and end points
        self.sensor_start_x = self.center - (self.len_sensor  / 2) * axis_vector  
        self.sensor_end_x = self.center + (self.len_sensor / 2) * axis_vector 

        # Pre-calculate dsensor and dsensor_y *outside* the loops
        dsensor = (self.sensor_end_x - self.sensor_start_x) / self.N


        sub_sensor = [self.sensor_start_x + i * dsensor + (self.ddx  / 2) * axis_vector for i in range(self.N)]
        # print(np.array(sub_sensor))
        self.points_sensor_0 = []
        for i in range(len(sub_sensor)):
            sensor_start_y_x = sub_sensor[i] - (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_start_y_x)
            sensor_end_y_x = sub_sensor[i] + (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_end_y_x)
            dsensor_y = (sensor_end_y_x-sensor_start_y_x)/self.N
            self.points_sensor_0.extend([sensor_start_y_x + j * dsensor_y + (self.ddx/2)*self.bitangent_norm_pos for j in range(self.N)])
        if R_sensor is None:
            self.points_sensor = self.points_sensor_0
        else:
            points_sensor_aux =  np.array(self.points_sensor_0)
            mask_r = np.where(np.linalg.norm(points_sensor_aux-self.center, axis = 1)<R_sensor)
            self.points_sensor = points_sensor_aux[mask_r[0]]


        

        if channel_1:
            self.points_sensor_1 = [self.points_sensor[i]+ (self.height+2*self.sensor_coil_shift)*self.outside for i in range(len(self.points_sensor))]
            self.points_sensor = self.points_sensor_1


        

        

        self.coils = self.calculate_coils()     #get the position of the points where the coils will be segmented   
        
        self.Hv = self.magnetic_field_coils(coordinates_nodes) # get the magnetic field for each coil

        # self.coil_current=self.coils_parameters['current'] 
        self.coil_current=np.array(self.coils_parameters['current'])
        
        self.u1 = self.Hv[0]+self.Hv[1]  #the external magnetic field for  unit current value  
        # self.u2 = self.Hv[1]+self.Hv[3]

        H12_norm = np.linalg.norm(self.u1, axis=1)
        self.u1_norm =  H12_norm[:,np.newaxis]

        self.H_a = self.u1/self.u1_norm
        '''here is the difference'''
        #indenpendence of the current on voxels
        self.b_1 = self.coil_current[:,np.newaxis]*H12_norm/np.max(H12_norm)  #for multiply the current for the activation coils vn*bi

        #indenpendence of the current on voxels
        self.b_2 = self.coil_current


        time_1 =time.time()
        self.G_led_field_matrices = self.get_led_field_matrices(parameters,psi,coordinates_nodes) 


        # print(-time_1 +time.time())



        self.integration_for_Ha = 4*lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes, self.H_a/self.u1_norm,np.ones(len(coordinates_nodes)))

        self.G_led_field_matrices_saturation = self.get_led_field_matrices_Saturation_Function(parameters,psi,coordinates_nodes) 

        
    

    def calculate_coils(self):
        'get the position of the coils point where it will be segmented'
            
        coil_offset = self.coil_shift/2 * self.tangent_vector
        coil_sensor_offset = self.sensor_coil_shift * self.outside

        center_coil1 = self.center + coil_offset + coil_sensor_offset
        center_coil2 = self.center - coil_offset + coil_sensor_offset

        coil_segment1 = self.get_coil_points(center_coil1)
        coil_segment2 = self.get_coil_points(center_coil2)
        # coil_segment2 = coil_segment1 - 2*coil_offset

        return coil_segment1, coil_segment2 

    
    def get_coil_points(self, center_coil):
        num_segments_per_turn = self.coils_parameters['num_segments_per_turn']
        num_turns = self.coils_parameters['num_turns']
        num_layer_wired = self.coils_parameters['num_layer_wired']

        height = self.height
        radios_helix = np.linspace(self.a_initial/2, self.a_final / 2, num_layer_wired)

        all_segments = []

        # Create segments for each layer
        for i in range(num_layer_wired):
            # Calculate the center for the current layer
            layer_center = center_coil + (i % 2) * height * self.outside
            # Generate the helical path parameters
            theta = np.linspace(0, 2 * np.pi * num_turns, num_turns * num_segments_per_turn + 1, endpoint=True)
            h = np.linspace(0, ((-1) ** i) * height, num_turns * num_segments_per_turn + 1)

            # Calculate coil points along the helix

            # Use NumPy broadcasting for vectorized calculation
            start_points = layer_center + (radios_helix[i] * np.cos(theta)[:, np.newaxis] * self.tangent_vector) + (radios_helix[i] * np.sin(theta)[:, np.newaxis] * (self.bitangent_vector)) + (h[:, np.newaxis] * self.outside)
            all_segments.extend(list(zip(start_points[:-1], start_points[1:])))

        return all_segments
    

    def save_to_csv(self, filename):

        coils_device1 = np.array(self.coils[0])[:, 0, :].tolist()+np.array(self.coils[1])[:, 0, :].tolist()+self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')

    def save_to_csv_plate(self, filename):
        coils_device1 = self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')


    def get_led_field_matrices(self, parameters,psi,coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
    
       
        fv1 = self.func_saturation(self.b_1)

        
        G_coil_current = []
        
        for i in range(fv1.shape[0]):
            if self.saturation:
                G_coil_1 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes, self.Hv[0]/self.u1_norm,fv1[i])
                G_coil_2 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes,  self.Hv[1]/self.u1_norm,fv1[i])
                G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.Hv[0]/self.u1_norm,fv1[i])
                G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.Hv[1]/self.u1_norm,fv1[i])
            else:
                G_coil_1 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes, self.b_2*self.Hv[0]/self.u1_norm)
                G_coil_2 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes,  self.b_2*self.Hv[1]/self.u1_norm)
                G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.b_2*self.Hv[0]/self.u1_norm)
                G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.b_2*self.Hv[1]/self.u1_norm)

            G_coil_current.append([G_coil_1, G_coil_2,G_coil_1_b, G_coil_2_b])

        return G_coil_current



    def get_led_field_matrices_Saturation_Function(self, parameters,psi,coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
    
       
        fv1 = self.func_saturation(self.b_1)/self.integration_for_Ha
        G_coil_current = []
        
        for i in range(fv1.shape[0]):
            if self.saturation:

                G_coil_1 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes, self.Hv[0]/self.u1_norm,fv1[i])
                G_coil_2 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes,  self.Hv[1]/self.u1_norm,fv1[i])
                G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.Hv[0]/self.u1_norm,fv1[i])
                G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.Hv[1]/self.u1_norm,fv1[i])
            else:
                G_coil_1 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes, self.b_2*self.Hv[0]/self.u1_norm)
                G_coil_2 = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                                [self.tangent_vector], coordinates_nodes,  self.b_2*self.Hv[1]/self.u1_norm)
                G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.b_2*self.Hv[0]/self.u1_norm)
                G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF_abs(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                    [self.bitangent_norm_pos], coordinates_nodes, self.b_2*self.Hv[1]/self.u1_norm)

            G_coil_current.append([G_coil_1, G_coil_2,G_coil_1_b, G_coil_2_b])

        return G_coil_current
    

    def magnetic_field_coils(self, coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
        # coil_current=self.coils_parameters['current'] 
        coil_current = 1   
        Hv1=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[0], coil_current)
        Hv2=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[1], -coil_current)
        return Hv1, Hv2
    


    def solve_forward_model(self, G_coil_matrices, concentration1, same_time=True):
        '''solve the forward model for the simulation of the signals'''
        '''if the same_time is true the G_coil_matrices is must be sum firt otherwise the G_coils_matrices has to be composed by two matrices'''
        # G_coil_matrices=self.get_led_field_matrices()
        noise_v = np.random.normal(0, 1, 2)
        if same_time is True:
            V_coil = G_coil_matrices.dot(concentration1)
            epsilon = LA.norm(V_coil) / (10 * np.linalg.norm(noise_v))
            V_noise_coil = V_coil + epsilon * noise_v
            return V_noise_coil
        else:
            #for the first coil
            V_coil1_1 = G_coil_matrices[0].dot(concentration1)
            epsilon1 = LA.norm(V_coil1_1) / (10 * np.linalg.norm(noise_v[0]))
            V_noise_coil1_1 = V_coil1_1 + epsilon1 * noise_v[0]

            #for the second coil
            V_coil2_1 = G_coil_matrices[1].dot(concentration1)
            epsilon2 = LA.norm(V_coil2_1) / (10 * np.linalg.norm(noise_v[1]))
            V_noise_coil2_1= V_coil2_1 + epsilon2 * noise_v[1]
            return V_noise_coil1_1,V_noise_coil2_1







class new_dimentions_two_cylinder_coils_DF_v2:
    '''This class simulate an experiment for the cube with devices located in the border '''
    def __init__(self, sensors,parameters_coil_device, current_coils,parameters,psi,coordinates_nodes, N,R_sensor=None, coils_aling_direction=None, saturation = True,channel_1 = False,  func_saturation = np.tanh):
        '''This class calculate the matrix associated for multiple currents for every device compuse by 2 coils which are excitated at the same time '''
        self.parameters_coil_device = parameters_coil_device
        self.current_coils = current_coils
        self.V_signals_sensor_current = []  #list of number_sensor lists of sesorsignals for each current 
        # current_coils=[7, 0.5, 0.7, 0.9, 1.27, 5, 2, 3]
        
        self.V_total_noise_current = []
        self.Dev_x = []
        self.G_x = []
        self.G_total_current = []

        self.G_x_saturation = []
        self.G_total_current_saturation = []
        self.sensors=sensors

        self.coils_aling_direction=coils_aling_direction
        self.parameters = parameters
        self.psi = psi
        self.coordinates_nodes = coordinates_nodes
        self.saturation = saturation
        self.channel_1 = channel_1 
        self.N = N
        self.R_sensor = R_sensor
        self.func_saturation = func_saturation
        self.parameters_coil_device['current'] = self.current_coils
        devices_x = [Cube_new_dimentions_channel1(self.sensors[i],self.parameters_coil_device,self.parameters,self.psi,self.coordinates_nodes, self.N, self.R_sensor,self.coils_aling_direction, self.saturation ,self.channel_1, self.func_saturation) for i in range(len(self.sensors))]
        self.Dev_x = devices_x

           
    def compute_G_devices(self):
        devices_x = self.Dev_x 
        for i in range(len(devices_x)):
            G_devices_x = [np.concatenate(([np.sum((devices_x[i].G_led_field_matrices[j][0], devices_x[i].G_led_field_matrices[j][1]), axis=0),
                           np.sum((devices_x[i].G_led_field_matrices[j][2], devices_x[i].G_led_field_matrices[j][3]), 
                                  axis=0)]),axis=0)
                            for j in range(len(self.current_coils))]
            self.G_x.append(G_devices_x)
            G_total_x = np.concatenate(G_devices_x, axis=0)
            # print(G_total_x)
            self.G_total_current.append(G_total_x)

        G_global1 = np.concatenate(self.G_total_current, axis=0)
        return G_global1



    def compute_G_devices_saturation(self):
        devices_x = self.Dev_x 
        for i in range(len(devices_x)):
            G_devices_x = [np.concatenate(([np.sum((devices_x[i].G_led_field_matrices_saturation[j][0], devices_x[i].G_led_field_matrices_saturation[j][1]), axis=0),
                           np.sum((devices_x[i].G_led_field_matrices_saturation[j][2], devices_x[i].G_led_field_matrices_saturation[j][3]), 
                                  axis=0)]),axis=0)
                            for j in range(len(self.current_coils))]
            self.G_x_saturation.append(G_devices_x)
            G_total_x = np.concatenate(G_devices_x, axis=0)
            # print(G_total_x)
            self.G_total_current_saturation.append(G_total_x)

        G_global1 = np.concatenate(self.G_total_current_saturation, axis=0)
        return G_global1

    def compute_V_total_noise(self, concentration):
        self.V_total_noise_current = []
        for k in range(len(self.Dev_x)):
            V_noise_devices_x = [self.Dev_x[k].solve_forward_model(self.G_x[k][i], concentration) for i in range(len(self.current_coils))]
            self.V_signals_sensor_current.append(V_noise_devices_x)
            V_total_noise_x = np.concatenate(V_noise_devices_x, axis=0)
            self.V_total_noise_current.append(V_total_noise_x)
        V_global1 = np.concatenate(self.V_total_noise_current, axis=0)
        return V_global1
    
    def plot_all_sensors_pv(self, index_sensor):
        sensors_points=[]
        for i in index_sensor:
            sensors_points.extend(self.Dev_x[i].points_sensor)
        return sensors_points


    def plot_n_device_some_coils_pv(self, index_sensor):
        coils_points=[]
        for i in index_sensor:
            coils_device1 = np.array(self.Dev_x[i].coils[0])[:, 0, :].tolist()+np.array(self.Dev_x[i].coils[1])[:, 0, :].tolist()
            coils_points.extend(np.array(coils_device1))
        return coils_points





    def plot_all_sensors(self, filename):
        self.sensors_points=[]
        for i in range(len(self.sensors)):
            self.sensors_points.extend(self.Dev_x[i].points_sensor)
        np.savetxt(filename,  self.sensors_points, delimiter=',', header='x,y,z', comments='')

    def plot_n_sensor(self, n_sensor, filename):
        self.Dev_x[n_sensor].save_to_csv_plate(filename)

    def plot_n_device(self, n_pizza,filename):
        self.Dev_x[n_pizza].save_to_csv(filename)


























#############################################3
## device with two coils for cylinder #########
##############################################

class Device_Experiment_Cylinder_all_currents:
    '''this class create the basic structure of the new device orientated in the axis x, y or z'''
    def __init__(self , center, coils_parameters, parameters,psi,coordinates_nodes, coils_aling_direction = None):
        '''initialize the device 
        center: center position of the device 
        orientation:'axis_coil's' might be oriented 'x', 'y' or 'z'
        coils_parameters: dictionary for the geometry of coils  helix  'num_segments_per_turn': ,'num_turns': in the ehlix of height h , 'axis' in which the coils will be oriented 
        coils_aling_direction: list of basisof the  plane where the divice is aling , the [0] component is where the coils are aling , [1] component of the wall, [2] sign for outs
        '''
        #geometri of the device
        self.height = 2*1e-2 #height of the cylinder using as coils 
        self.sensor_coil_shift = 0.4*1e-2 #distance between the center of device to the sensors
        self.len_sensor = 1.4*1e-2
        self.sensor_shift = 0.03*1e-2
        self.N=14 #number of points in the sensor 

        self.coil_shift = 4.5*1e-2  #distance between the centers of of the coils 
        self.a_initial = 2.5*1e-2 # diameter of the begining of the cylinder
        self.a_final = 4.4*1e-2  #diameter of the end of the cylinder after wiring

        self.coils_parameters = coils_parameters #parameter of the coils

        # Define the normal vector (outward-pointing from the cylinder surface) at the starting point
        normal_vector = center/ np.linalg.norm(center)
        # normal_vector = np.array([0, 1, 0])

        # Define the tangent vector (along the cylinder's circumference)
        if coils_aling_direction == None:
            self.tangent_vector = np.array([1, 0, 0])
            self.bitangent_vector = np.array([0, 1, 0])
            self.out_sign = -1

        else:
            self.tangent_vector = coils_aling_direction[0]
            self.bitangent_vector = coils_aling_direction[1]
            self.out_sign = coils_aling_direction[2]
        
        

        # # Define the bitangent vector (perpendicular to the cylinder, outwards or inwards)
        # bitangent_vector = np.cross(normal_vector, self.tangent_vector)
        # self.bitangent_vector = bitangent_vector / np.linalg.norm(bitangent_vector)
        outside = np.cross(self.bitangent_vector,self.tangent_vector)
        self.outside = np.abs(outside)/np.linalg.norm(outside)*self.out_sign


        self.center = np.array(center)+self.sensor_shift *self.outside 
        self.sensor_start = self.center - (self.len_sensor/2)* self.tangent_vector 
        self.sensor_end = self.center + (self.len_sensor/2)* self.tangent_vector


        self.bitangent_norm_pos = (self.bitangent_vector)/np.linalg.norm(self.bitangent_vector)
        # Pre-calculate the axis vector
        axis_vector = self.tangent_vector

        # Pre-calculate sensor start and end points
        self.sensor_start_x = self.center - (self.len_sensor / 2) * axis_vector
        self.sensor_end_x = self.center + (self.len_sensor / 2) * axis_vector

        # Pre-calculate dsensor and dsensor_y *outside* the loops
        dsensor = (self.sensor_end_x - self.sensor_start_x) / self.N
        sub_sensor = [self.sensor_start_x + i * dsensor for i in range(self.N)]
        # print(np.array(sub_sensor))
        self.points_sensor = []
        for i in range(len(sub_sensor)):
            sensor_start_y_x = sub_sensor[i] - (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_start_y_x)
            sensor_end_y_x = sub_sensor[i] + (self.len_sensor/2)*self.bitangent_norm_pos
            # print(sensor_end_y_x)
            dsensor_y = (sensor_end_y_x-sensor_start_y_x)/self.N
            self.points_sensor.extend([sensor_start_y_x + j * dsensor_y for j in range(self.N)])

        self.ddx=self.len_sensor /self.N

        self.coils = self.calculate_coils()     #get the position of the points where the coils will be segmented   
        
        self.Hv = self.magnetic_field_coils(coordinates_nodes) # get the magnetic field for each coil

        # self.coil_current=self.coils_parameters['current'] 
        self.coil_current=np.array(self.coils_parameters['current'])
        
        self.u1 = self.Hv[0]+self.Hv[1]
        # self.u2 = self.Hv[1]+self.Hv[3]

        H12_norm = np.linalg.norm(self.u1, axis=1)
        '''here is the difference'''
        self.b_1 = self.coil_current[:,np.newaxis]*H12_norm/np.max(H12_norm)  #for multiply the current for the activation coils vn*bi

        self.G_led_field_matrices = self.get_led_field_matrices(parameters,psi,coordinates_nodes) 


    

    def calculate_coils(self):
        'get the position of the coils point where it will be segmented'
            
        coil_offset = self.coil_shift/2 * self.tangent_vector
        coil_sensor_offset = self.sensor_coil_shift * self.outside

        center_coil1 = self.center + coil_offset + coil_sensor_offset
        center_coil2 = self.center - coil_offset + coil_sensor_offset

        coil_segment1 = self.get_coil_points(center_coil1)
        coil_segment2 = self.get_coil_points(center_coil2)
        # coil_segment2 = coil_segment1 - 2*coil_offset

        return coil_segment1, coil_segment2 

    
    def get_coil_points(self, center_coil):
        num_segments_per_turn = self.coils_parameters['num_segments_per_turn']
        num_turns = self.coils_parameters['num_turns']
        num_layer_wired = self.coils_parameters['num_layer_wired']

        height = self.height
        radios_helix = np.linspace(self.a_initial/2, self.a_final / 2, num_layer_wired)

        all_segments = []

        # Create segments for each layer
        for i in range(num_layer_wired):
            # Calculate the center for the current layer
            layer_center = center_coil + (i % 2) * height * self.outside
            # Generate the helical path parameters
            theta = np.linspace(0, 2 * np.pi * num_turns, num_turns * num_segments_per_turn + 1, endpoint=True)
            h = np.linspace(0, ((-1) ** i) * height, num_turns * num_segments_per_turn + 1)

            # Calculate coil points along the helix

            # Use NumPy broadcasting for vectorized calculation
            start_points = layer_center + (radios_helix[i] * np.cos(theta)[:, np.newaxis] * self.tangent_vector)+ (radios_helix[i] * np.sin(theta)[:, np.newaxis] * (self.bitangent_vector)) + (h[:, np.newaxis] * self.outside)
            all_segments.extend(list(zip(start_points[:-1], start_points[1:])))

        return all_segments
    

    def save_to_csv(self, filename):

        coils_device1 = np.array(self.coils[0])[:, 0, :].tolist()+np.array(self.coils[1])[:, 0, :].tolist()+self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')

    def save_to_csv_plate(self, filename):
        coils_device1 = self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')


    def get_led_field_matrices(self, parameters,psi,coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
    
        # a_s = -1*self.outside

        fv1 = np.tanh(self.b_1/10)  
        G_coil_current = []

        for i in range(fv1.shape[0]):
            G_coil_1 = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes, self.Hv[0],fv1[i])
            G_coil_2 = psi * lead_field_matrix_coil_Hv_fn_DF(parameters,  np.array(self.points_sensor),self.ddx, self.N ,
                                                               [self.tangent_vector], coordinates_nodes,  self.Hv[1],fv1[i])
            G_coil_1_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                [self.bitangent_norm_pos], coordinates_nodes, self.Hv[0],fv1[i])
            G_coil_2_b = psi * lead_field_matrix_coil_Hv_fn_DF(parameters, np.array(self.points_sensor),self.ddx, self.N,
                                                                  [self.bitangent_norm_pos], coordinates_nodes, self.Hv[1],fv1[i])
            G_coil_current.append([G_coil_1, G_coil_2,G_coil_1_b, G_coil_2_b])

        return G_coil_current
    

    def magnetic_field_coils(self, coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
        # coil_current=self.coils_parameters['current'] 
        coil_current = 1   
        Hv1=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[0], coil_current)
        Hv2=coil_magnetic_field_total_fast(coordinates_nodes, self.coils[1], -coil_current)
        return Hv1, Hv2
    
    def solve_forward_model(self, G_coil_matrices, concentration1, same_time=True):
        '''solve the forward model for the simulation of the signals'''
        '''if the same_time is true the G_coil_matrices is must be sum firt otherwise the G_coils_matrices has to be composed by two matrices'''
        # G_coil_matrices=self.get_led_field_matrices()
        noise_v = np.random.normal(0, 1, 2)
        if same_time is True:
            V_coil = G_coil_matrices.dot(concentration1)
            epsilon = LA.norm(V_coil) / (10 * np.linalg.norm(noise_v))
            V_noise_coil = V_coil + epsilon * noise_v
            return V_noise_coil
        else:
            #for the first coil
            V_coil1_1 = G_coil_matrices[0].dot(concentration1)
            epsilon1 = LA.norm(V_coil1_1) / (10 * np.linalg.norm(noise_v[0]))
            V_noise_coil1_1 = V_coil1_1 + epsilon1 * noise_v[0]

            #for the second coil
            V_coil2_1 = G_coil_matrices[1].dot(concentration1)
            epsilon2 = LA.norm(V_coil2_1) / (10 * np.linalg.norm(noise_v[1]))
            V_noise_coil2_1= V_coil2_1 + epsilon2 * noise_v[1]
            return V_noise_coil1_1,V_noise_coil2_1





class two_cylinder_coils_DF:
    '''This class simulate an experiment for the cube with devices located in the border '''
    def __init__(self, sensors,parameters_coil_device, current_coils,parameters,psi,coordinates_nodes, coils_aling_direction=None):
        '''This class calculate the matrix associated for multiple currents for every device compuse by 2 coils which are excitated at the same time '''
        self.parameters_coil_device = parameters_coil_device
        self.current_coils = current_coils
        self.V_signals_sensor_current = []  #list of number_sensor lists of sesorsignals for each current 
        # current_coils=[7, 0.5, 0.7, 0.9, 1.27, 5, 2, 3]
        self.G_total_current = []
        self.V_total_noise_current = []
        self.Dev_x = []
        self.G_x = []
        self.sensors=sensors

        self.coils_aling_direction=coils_aling_direction
        self.parameters = parameters
        self.psi = psi
        self.coordinates_nodes = coordinates_nodes


           
    def compute_G_devices(self):
        self.parameters_coil_device['current'] = self.current_coils
        devices_x = [Device_Experiment_Cylinder_all_currents(self.sensors[i],self.parameters_coil_device,self.parameters,self.psi,self.coordinates_nodes, self.coils_aling_direction) for i in range(len(self.sensors))]
        self.Dev_x = devices_x
        for i in range(len(devices_x)):
            G_devices_x = [np.concatenate(([np.sum((devices_x[i].G_led_field_matrices[j][0], devices_x[i].G_led_field_matrices[j][1]), axis=0),
                           np.sum((devices_x[i].G_led_field_matrices[j][2], devices_x[i].G_led_field_matrices[j][3]), 
                                  axis=0)]),axis=0)
                            for j in range(len(self.current_coils))]
            self.G_x.append(G_devices_x)
            G_total_x = np.concatenate(G_devices_x, axis=0)
            # print(G_total_x)
            self.G_total_current.append(G_total_x)

        G_global1 = np.concatenate(self.G_total_current, axis=0)
        return G_global1

    def compute_V_total_noise(self, concentration):
        self.V_total_noise_current = []
        for k in range(len(self.Dev_x)):
            V_noise_devices_x = [self.Dev_x[k].solve_forward_model(self.G_x[k][i], concentration) for i in range(len(self.current_coils))]
            self.V_signals_sensor_current.append(V_noise_devices_x)
            V_total_noise_x = np.concatenate(V_noise_devices_x, axis=0)
            self.V_total_noise_current.append(V_total_noise_x)
        V_global1 = np.concatenate(self.V_total_noise_current, axis=0)
        return V_global1
    
    def plot_all_sensors(self, index_sensor):
        sensors_points=[]
        for i in index_sensor:
            sensors_points.extend(self.Dev_x[i].points_sensor)
        return sensors_points


    def plot_n_device_some_coils(self, index_sensor):
        coils_points=[]
        for i in index_sensor:
            coils_device1 = np.array(self.Dev_x[i].coils[0])[:, 0, :].tolist()+np.array(self.Dev_x[i].coils[1])[:, 0, :].tolist()
            coils_points.extend(np.array(coils_device1))
        return coils_points

    # def plot_n_device(self, n_pizza, filename):
    #     self.Dev_x[n_pizza].save_to_csv(filename)




    def plot_all_sensors_f(self, filename):
        self.sensors_points=[]
        for i in range(len(self.sensors)):
            self.sensors_points.extend(self.Dev_x[i].points_sensor)
        np.savetxt(filename,  self.sensors_points, delimiter=',', header='x,y,z', comments='')

    def plot_n_sensor(self, n_sensor, filename):
        self.Dev_x[n_sensor].save_to_csv_plate(filename)

    def plot_n_device(self, n_pizza,filename):
        self.Dev_x[n_pizza].save_to_csv(filename)

    


















##################################################
## device with 6 coils, one over the sensor #######
#################################################






class Device_Experiment_Cylinder_as_coil_all_currents:
    '''this class create the basic structure of the new device orientated in the axis x, y or z'''
    def __init__(self , center, coils_parameters,parameters,psi,Space,coordinates_nodes, basis_function_test,N):
        '''initialize the device 
        center: center position of the device 
        orientation:'axis_coil's' might be oriented 'x', 'y' or 'z'
        coils_parameters: dictionary for the geometry of coils  helix  'num_segments_per_turn': ,'num_turns': in the ehlix of height h , 'axis' in which the coils will be oriented 
        '''
        #geometri of the device
        self.height = 2*1e-2 #height of the cylinder using as coils 
        # self.sensor_coil_shift = 0.4*1e-2 #distance between the center of device to the sensors
        self.len_sensor = 1.4*1e-2
        self.sensor_shift = 0.1*1e-2
        self.N_coils =N
        self.N_sensor_dis=14 #number of points in the sensor 

        # self.coil_shift = 4.5*1e-2  #distance between the centers of of the coils 
        self.a_initial = 2.5*1e-2 # diameter of the begining of the cylinder
        self.a_final = 4.4*1e-2  #diameter of the end of the cylinder after wiring

        self.coils_parameters = coils_parameters #parameter of the coils

        # Define the normal vector (outward-pointing from the cylinder surface) at the starting point
        normal_vector = center/ np.linalg.norm(center)
        # normal_vector = np.array([0, 1, 0])

        # Define the tangent vector (along the cylinder's circumference)
        self.tangent_vector = np.array([1, 0, 0])

        # Define the bitangent vector (perpendicular to the cylinder, outwards or inwards)
        bitangent_vector = np.cross(normal_vector, self.tangent_vector)
        self.bitangent_vector = bitangent_vector / np.linalg.norm(bitangent_vector)
        outside = np.cross(bitangent_vector,self.tangent_vector)
        self.outside = -1*outside/np.linalg.norm(outside)


        self.center = np.array(center)+self.sensor_shift *self.outside 
        self.sensor_start = self.center - (self.len_sensor/2)* self.tangent_vector 
        self.sensor_end = self.center + (self.len_sensor/2)* self.tangent_vector


        # self.bitangent_norm_pos = self.bitangent_vector
        # Pre-calculate the axis vector


        # Pre-calculate sensor start and end points
        self.sensor_start_x = self.center - (self.len_sensor / 2) * self.tangent_vector
        self.sensor_end_x = self.center + (self.len_sensor / 2) * self.tangent_vector

        # Pre-calculate dsensor and dsensor_y *outside* the loops
        dsensor = (self.sensor_end_x - self.sensor_start_x) / self.N_sensor_dis
        sub_sensor = [self.sensor_start_x + i * dsensor for i in range(self.N_sensor_dis)]
        # print(np.array(sub_sensor))
        self.points_sensor = []
        for i in range(len(sub_sensor)):
            sensor_start_y_x = sub_sensor[i] - (self.len_sensor/2)*self.bitangent_vector
            # print(sensor_start_y_x)
            sensor_end_y_x = sub_sensor[i] + (self.len_sensor/2)*self.bitangent_vector
            # print(sensor_end_y_x)
            dsensor_y = (sensor_end_y_x-sensor_start_y_x)/self.N_sensor_dis
            self.points_sensor.extend([sensor_start_y_x + j * dsensor_y for j in range(self.N_sensor_dis)])

        self.ddx=self.len_sensor /self.N_sensor_dis



        self.coils = self.calculate_coils()     #get the position of the points where the coils will be segmented   

        self.Hv = self.magnetic_field_coils(coordinates_nodes) # get the magnetic field for each coil

        # self.coil_current=self.coils_parameters['current'] 
        self.coil_current=np.array(self.coils_parameters['current'])
        

        # self.u = self.Hv
        # self.u2 = self.Hv[1]+self.Hv[3]

        H12_norm = [np.linalg.norm(self.Hv[i], axis=1) for i in range(self.N_coils)]
        '''here is the difference'''
        self.b_1 = [self.coil_current[:,np.newaxis]*H12_norm[i]/np.max(H12_norm[i])  for i in range(self.N_coils)]  #for multiply the current for the activation coils vn*bi

        self.G_led_field_matrices = self.get_led_field_matrices(parameters,psi,Space,coordinates_nodes, basis_function_test) 

    


    def calculate_coils(self):
        'get the position of the coils point where it will be segmented'
        alpha_angle = np.arctan2(self.center[2],self.center[1])  #angle of the center of the sensor 
        radio = np.linalg.norm(np.array((self.center[1],self.center[2]))) # radius of the center of the sensor 
        angles = np.linspace(alpha_angle, alpha_angle+2* np.pi, self.N_coils,endpoint=False)
        self.angles_coils = angles


        '''create the point of the center of coils cylinder including one coil over the sensor '''
        x = self.center[0]  * np.ones(self.N_coils)  # Height stays the same
        y = radio * np.cos(angles)  # X coordinate
        z = radio * np.sin(angles)  # Y coordinate
        
        # Stack the coordinates and reshape for output
        centers_coils = np.column_stack((x, y, z))
        self.center_coils=centers_coils
        
        segment_coils = []
        for i in range(self.N_coils):
            segment_coils.append(self.get_coil_points(centers_coils[i]))

        return segment_coils
    

    def get_coil_points(self, center_coil):
        num_segments_per_turn = self.coils_parameters['num_segments_per_turn']
        num_turns = self.coils_parameters['num_turns']
        num_layer_wired = self.coils_parameters['num_layer_wired']

        height = self.height
        radios_helix = np.linspace(self.a_initial/2, self.a_final / 2, num_layer_wired)
        normal_vector = center_coil/ np.linalg.norm(center_coil)
        tangent_vector = np.array([1, 0, 0])

        # Define the bitangent vector (along the cylinder height)
        bitangent_vector = np.cross(normal_vector, tangent_vector)
        bitangent_vector /= np.linalg.norm(bitangent_vector)
        outside = np.cross(bitangent_vector,tangent_vector)
        outside = -1*outside/np.linalg.norm(outside)


        all_segments = []

        # Create segments for each layer
        for i in range(num_layer_wired):
            # Calculate the center for the current layer
            layer_center = center_coil + (i % 2) * height * outside
            # Generate the helical path parameters
            theta = np.linspace(0, 2 * np.pi * num_turns, num_turns * num_segments_per_turn + 1, endpoint=True)
            h = np.linspace(0, ((-1) ** i) * height, num_turns * num_segments_per_turn + 1)

            # Calculate coil points along the helix

            # Use NumPy broadcasting for vectorized calculation
            start_points = layer_center + (radios_helix[i] * np.cos(theta)[:, np.newaxis] * tangent_vector) + (radios_helix[i] * np.sin(theta)[:, np.newaxis] * bitangent_vector) + (h[:, np.newaxis] * outside)
            all_segments.extend(list(zip(start_points[:-1], start_points[1:])))

        return all_segments
    

    def magnetic_field_coils(self,coordinates_nodes):
        '''This function get the field matrices for the segmentations getting for the coils'''
        # coil_current=self.coils_parameters['current'] 
        coil_current = 1 
        Hv_s=[]
        for i in range(self.N_coils):
            Hv_s.append(coil_magnetic_field_total_fast(coordinates_nodes, self.coils[i], coil_current))
        return Hv_s
    


    def get_led_field_matrices(self,parameters,psi,Space,coordinates_nodes, basis_function_test):
        '''This function get the field matrices for the segmentations getting for the coils'''
    
        # a_s = -1*self.outside
        fv1 = [np.tanh(self.b_1[j]/10) for j in range(len(self.b_1))]
        # G_coils=[]
        G_coil_current = [] 
        #fv1[0].shape[0] is equal to number of currents 
        for i in range(fv1[0].shape[0]):
            # fv1 = np.tanh(self.b_1[j]/10)
            G_coil_current_1_sensitive_current = []
            G_coil_current_2_sensitive_current = []
            for j in range(self.N_coils):
                G_coil_1 = psi * lead_field_matrix_coil_fast3_Hv_fn(parameters, Space, np.array(self.points_sensor),self.ddx, self.N_sensor_dis,
                                                                    [self.tangent_vector], coordinates_nodes, basis_function_test, self.Hv[j],fv1[j][i])
                G_coil_1_b = psi * lead_field_matrix_coil_fast3_Hv_fn(parameters, Space, np.array(self.points_sensor),self.ddx, self.N_sensor_dis,
                                                                      [self.bitangent_vector], coordinates_nodes, basis_function_test, self.Hv[j],fv1[j][i])
                G_coil_current_1_sensitive_current.append(G_coil_1)
                G_coil_current_2_sensitive_current.append(G_coil_1_b)
            #for each sensor and for each current we have `12 matrix (list of n_currents   list of 12 matrix )
            G_coil_current.append(G_coil_current_1_sensitive_current+G_coil_current_2_sensitive_current)
        return G_coil_current

    

    def save_to_csv(self, filename):
        coils_device1=[]
        for i in range(self.N_coils):
            coils_device1.extend(np.array(self.coils[i])[:, 0, :].tolist())
        # coils_device1.extend(self.points_sensor)        
        # coils_device1 = np.array(self.coils[0])[:, 0, :].tolist()+np.array(self.coils[1])[:, 0, :].tolist()+self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')


    def save_to_csv_plate(self, filename):
        coils_device1 = self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')
    

    def save_to_csv_some_coils(self,filename, index_coils):
        coils_device1=[]
        for i in index_coils:
            coils_device1.extend(np.array(self.coils[i])[:, 0, :].tolist())
        # coils_device1.extend(self.points_sensor)        
        # coils_device1 = np.array(self.coils[0])[:, 0, :].tolist()+np.array(self.coils[1])[:, 0, :].tolist()+self.points_sensor
        np.savetxt(filename, coils_device1, delimiter=',', header='x,y,z', comments='')



    def solve_forward_model(self, G_coil_matrices, concentration1, same_time=True):
        '''solve the forward model for the simulation of the signals'''
        '''if the same_time is true the G_coil_matrices is must be sum firt otherwise the G_coils_matrices has to be composed by two matrices'''
        # G_coil_matrices=self.get_led_field_matrices()
        noise_v = np.random.normal(0, 1, 2*self.N_coils)
        if same_time is True:
            V_coil = G_coil_matrices.dot(concentration1)
            epsilon = LA.norm(V_coil) / (10 * np.linalg.norm(noise_v))
            V_noise_coil = V_coil + epsilon * noise_v[0]
            return V_noise_coil
        else:
            #for the first coil
            V_coil1_1 = G_coil_matrices[0].dot(concentration1)
            epsilon1 = LA.norm(V_coil1_1) / (10 * np.linalg.norm(noise_v[0]))
            V_noise_coil1_1 = V_coil1_1 + epsilon1 * noise_v[0]

            #for the second coil
            V_coil2_1 = G_coil_matrices[1].dot(concentration1)
            epsilon2 = LA.norm(V_coil2_1) / (10 * np.linalg.norm(noise_v[1]))
            V_noise_coil2_1= V_coil2_1 + epsilon2 * noise_v[1]
            return V_noise_coil1_1,V_noise_coil2_1
        


    def segment_bitangent_diameter_coil_j(self, coil_j):
        # num_segments_per_turn = self.coils_parameters['num_segments_per_turn']
        # num_turns = self.coils_parameters['num_turns']
        # num_layer_wired = self.coils_parameters['num_layer_wired']
        radios_helix = np.linspace(self.a_initial/2, self.a_final / 2, 2)



        normal_vector = self.center_coils[coil_j]/ np.linalg.norm(self.center_coils[coil_j])
        tangent_vector = np.array([1, 0, 0])

        # Define the bitangent vector (along the cylinder height)
        bitangent_vector = np.cross(normal_vector, tangent_vector)
        bitangent_vector /= np.linalg.norm(bitangent_vector)
        
        
        
        outside = np.cross(bitangent_vector,tangent_vector)
        outside = -1*outside/np.linalg.norm(outside)


        all_segments = []
        # alpha_angles=[]

        # Create segments for each layer
        for i in range(2):
            # Calculate the center for the current layer
            layer_center = self.center_coils[coil_j]


            # Generate the helical path parameters
            theta = np.linspace(np.pi/2, 3/2 * np.pi,2, endpoint=True)
            # Use NumPy broadcasting for vectorized calculation
            start_points = layer_center + (radios_helix[i] * np.cos(theta)[:, np.newaxis] * tangent_vector) + (radios_helix[i] * np.sin(theta)[:, np.newaxis] * bitangent_vector) 
            # print(start_points.shape)
            # alpha_angle = [np.arctan2(start_points[0,2],start_points[0,1]), np.arctan2(start_points[1,2],start_points[1,1])] #angle of the center of the sensor 
            # alpha_angles.append(alpha_angle)
            # print('start points',start_points[0], start_points[1],'angles',alpha_angle)
            all_segments.append(start_points)
   
        return all_segments#alpha_angles



'''
Class more realistic for take the data and each position for all currents and then changes the position of the devices and take the data for all currents and so on
'''
class six_cylinder_coils:
    '''This class simulate an experiment for the cube with devices located in the border '''
    def __init__(self, sensors,parameters_coil_device, current_coils,parameters,psi,Space,coordinates_nodes, basis_function_test,N):
        '''This class calculate the matrix associated for multiple currents for every device compuse by 2 coils which are excitated at the same time '''
        self.N_coils = N
        self.parameters_coil_device = parameters_coil_device
        self.current_coils = current_coils
        self.V_signals_sensor_current = [] 
        # current_coils=[7, 0.5, 0.7, 0.9, 1.27, 5, 2, 3]
        
        self.V_total_noise_current = []
        self.Dev_x = [] #list class of the device for each sensor 
        self.G_x = []  #list of the number_sensors  list of number_currents matrices (order 4 by nodes)
        self.G_total_current = [] #list of matrices concatanete for each sensor 
        self.sensors=sensors

        self.parameters = parameters
        self.psi = psi
        self.Space = Space
        self.coordinates_nodes = coordinates_nodes
        self.basis_function_test = basis_function_test
           
    def compute_G_devices(self):
        self.parameters_coil_device['current'] = self.current_coils
        devices_x = [Device_Experiment_Cylinder_as_coil_all_currents(self.sensors[i],self.parameters_coil_device,self.parameters,self.psi,self.Space,self.coordinates_nodes, self.basis_function_test, self.N_coils) for i in range(len(self.sensors))]
        self.Dev_x = devices_x
        for i in range(len(devices_x)):
            G_devices_x = [np.concatenate(devices_x[i].G_led_field_matrices[j], axis=0) for j in range(len(self.current_coils))]
            self.G_x.append(G_devices_x)
            G_total_x = np.concatenate(G_devices_x, axis=0) #concatenate all the currents
            # print(G_total_x.shape)
            self.G_total_current.append(G_total_x) #add for the matrix of the new position sensor
        G_global1 = np.concatenate(self.G_total_current, axis=0) #concatenate the total for all the positions of the sensors
        return G_global1
    
    def center_coils(self,n_sensor):
        center_coils_n_sensor = self.Dev_x[n_sensor].center_coils
        return center_coils_n_sensor
    
    def angles_coils(self,n_sensor):
        angles_coils_n_sensor = self.Dev_x[n_sensor].angles_coils
        return angles_coils_n_sensor
    

    def angles_interval_intersection_coil_j(self,n_sensor,coil_j):
        '''calculate the angles of the border of circle coils'''
        points = self.Dev_x[n_sensor].segment_bitangent_diameter_coil_j(coil_j)
        alpha_angle = [[np.arctan2(points[0][0,2],points[0][0,1]), np.arctan2(points[0][1,2],points[0][1,1])], 
                       [np.arctan2(points[1][0,2],points[1][0,1]), np.arctan2(points[1][1,2],points[1][1,1])]]#angle of the center of the sensor
        
        angle=np.array(alpha_angle)
        angle[angle < 0] += 2 * np.pi 
        
        return angle

    
    def compute_V_total_noise(self, concentration):
        self.V_total_noise_current = []
        for k in range(len(self.Dev_x)):
            V_noise_devices_x = [self.Dev_x[k].solve_forward_model(self.G_x[k][i], concentration) for i in range(len(self.current_coils))]
            # print(len(V_noise_devices_x))
            self.V_signals_sensor_current.append(V_noise_devices_x)
            V_total_noise_x = np.concatenate(V_noise_devices_x, axis=0)
            self.V_total_noise_current.append(V_total_noise_x)
        V_global1 = np.concatenate(self.V_total_noise_current, axis=0)
        return V_global1
    
    def plot_all_sensors(self, filename):
        self.sensors_points=[]
        for i in range(len(self.sensors)):
            self.sensors_points.extend(self.Dev_x[i].points_sensor)
        np.savetxt(filename,  self.sensors_points, delimiter=',', header='x,y,z', comments='')

    def plot_n_sensor(self, n_sensor, filename):
        self.Dev_x[n_sensor].save_to_csv_plate(filename)

    def plot_n_device(self, n_pizza,filename):
        self.Dev_x[n_pizza].save_to_csv(filename)

    def plot_n_device_some_coils(self, n_pizza,index_coils,filename):
        self.Dev_x[n_pizza].save_to_csv_some_coils(filename,index_coils)

